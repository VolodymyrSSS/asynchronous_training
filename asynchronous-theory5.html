<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>asynchronous_theory5</title>
    <style>
    body {
        background-color: tan;
        margin: 0;
        font-family: Verdana, sans-serif;
    }

    .title {
        color: red;
        text-align: center;
        font-weight:700;
    }

    .code-ex {
        width: 50%;
        font-family: sans-serif;
        background-color: #bebebe;
        font-size: large;
        text-indent: 0;
        padding-left: 15px;
        margin: 0 auto;
    }

    p {
      text-indent: 30px;
    }

    </style>
</head>
<body>

  <h2 class="title">Асинхронный код: промисы</h2>

  <h3>Kонструктор promise</h3>

  <p> Eще один способ работы с асинхронным кодом или удобный способ организации асинхронного кода 
    - называется <b>Promises</b>. В современном JavaScript промисы часто используются в том числе 
    и неявно, при помощи генераторов.<br>
    Для того чтобы создать promise, нам нужно вызвать <b><em>конструктор promise</em></b> и передать 
    первым аргументом функцию. Внутри этой функции будет содержаться работа с асинхронным кодом.<br>
    Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise 
    создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь 
    создаст результат.<br>
    Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript. Наш код – только 
    внутри исполнителя.
  </p>

  <p class="code-ex">
    <code>
      var promise = <b>new Promise(function (resolve, reject)</b> {<br>
        // функция-исполнитель (executor)<br>
        <br>
        // В ней можно делать любые асинхронные операции,<br>
        // А когда они завершатся — нужно вызвать одно из:
        // resolve(результат) при успешном выполнении
        // reject(ошибка) при ошибке<br>
      });<br>
    </code>
  </p>

  <p>Если чтение файла завершилось с ошибкой, то мы вызываем <b><em>функцию reject</em></b>, куда передаем 
    информацию об ошибке.<br> Если чтение файла было удачно, то мы вызываем <b><em>функцию resolve</em></b>.</br>
  </p>

  <p>Рассмотрим пример1 поместим наш код (setTimeout) внутрь функции-исполнителя:</p>

  <p class="code-ex">
    <code>
      let promise = new Promise(function(resolve, reject) {<br>
        // эта функция выполнится автоматически, при вызове new Promise<br>
        // через 1 секунду сигнализировать, что задача выполнена с результатом "done"<br>
        setTimeout(() => resolve("done"), 1000);<br>
      });<br>
    </code>
  </p>

  <p>Мы можем наблюдать две вещи, запустив код выше:<br>
    1. Функция-исполнитель запускается сразу же при вызове new Promise.<br>
    2. Исполнитель получает два аргумента: resolve и reject — это функции, встроенные в JavaScript, 
    поэтому нам не нужно их писать. Нам нужно лишь позаботиться, чтобы исполнитель вызвал одну из 
    них по готовности.<br>
    Спустя одну секунду «обработки» исполнитель вызовет resolve("done"), чтобы передать результат.<br>
    Это был пример успешно выполненной задачи, в результате мы получили «успешно выполненный» промис.
  </p>

  <p>Рассмотрим пример2 в котором исполнитель сообщит, что задача выполнена с ошибкой:</p>

  <p class="code-ex">
    <code>
      let promise = new Promise(function(resolve, reject) {<br>
        // спустя одну секунду будет сообщено, что задача выполнена с ошибкой<br>
        setTimeout(() => reject(new Error("Whoops!")), 1000);<br>
      });<br>
    </code>
  </p>

  <p>Подведём промежуточные итоги: исполнитель выполняет задачу (что-то, что обычно требует времени), 
    затем вызывает resolve или reject, чтобы изменить состояние соответствующего Promise.<br>
    Промис – и успешный, и отклонённый будем называть «завершённым», в отличие от изначального промиса 
    «в ожидании».
  </p>

  <p>Рассмотрим пример3 и в качестве параметров в функцию resolve мы передаем содержимое файла. В нашем 
    случае мы будем читать файл data.json.
  </p> 

  <p class="code-ex">
    <code>
      var promise = new Promise(function (resolve, reject) {<br>
        <b>fs.readFile('data.json', function (err, data) {</b><br>
          <br>
        <b>});</b><br> 
      });<br>
    </code>
  </p>
  
  <p>Как только мы создали promise, он находится в <em>состоянии pending</em> — неопределенное состояние. 
    Если асинхронная операция завершилась хорошо, то есть позвали метод resolve, то promise переходит в 
    <b><em>состояние fulfilled</em></b>. Если во время выполнения асинхронной операции произошла ошибка или 
    позвали метод reject, то promise переходит в <b><em>состояние rejected</em></b>. Оба эти состояния 
    являются конечными, то есть как только promise в них перешел, больше он не может поменять своего 
    состояния.
  </p>
   
  <p class="code-ex">
    <code>
      var promise = new Promise(function (resolve, reject) {<br>
        fs.readFile('data.json', function (err, data) {<br>
          <b>if (err) {<br>
            reject(err);<br>
          } else {<br>
            resolve(data);}</b><br>
        });<br>
      });<br>
    </code>
  </p>

  <h3>Может быть что-то одно: либо результат, либо ошибка</h3>

  <p>Исполнитель должен вызвать что-то одно: resolve или reject. Состояние промиса может быть изменено 
    только один раз. Все последующие вызовы resolve и reject будут проигнорированы:
  </p>

  <p class="code-ex">
    <code>
      let promise = new Promise(function(resolve, reject) {<br>
        resolve("done");<br>
      <br>
        reject(new Error("…")); // игнорируется<br>
        setTimeout(() => resolve("…")); // игнорируется<br>
      });<br>
    </code>
  </p>

  <p>Идея в том, что задача, выполняемая исполнителем, может иметь только один итог: результат или ошибку.
    Также заметим, что функция resolve/reject ожидает только один аргумент (или ни одного). Все 
    дополнительные аргументы будут проигнорированы.
  </p>

  <p>В случае, если что-то пошло не так, мы должны вызвать reject. Это можно сделать с аргументом любого 
    типа (как и resolve), но рекомендуется использовать объект Error (или унаследованный от него).<br>
  </p>

  <p>Обычно исполнитель делает что-то асинхронное и после этого вызывает resolve/reject, то есть 
    через какое-то время. Но это не обязательно, resolve или reject могут быть вызваны сразу:
  </p>
  
  <p class="code-ex">
    <code>
      let promise = new Promise(function(resolve, reject) {<br>
        // задача, не требующая времени<br>
        resolve(123); // мгновенно выдаст результат: 123<br>
      });<br>
    </code>
  </p>
  
  <p>Это может случиться, например, когда мы начали выполнять какую-то задачу, но тут же увидели, 
    что ранее её уже выполняли, и результат закеширован. Такая ситуация нормальна. Мы сразу получим 
    успешно завершённый Promise.
  </p>

  <p>Свойства state и result – это внутренние свойства объекта Promise и мы не имеем к ним прямого 
    доступа. Для обработки результата следует использовать методы .then/.catch/.finally, про них речь 
    пойдёт дальше.
  </p>

  <h3>Pезультат работы promise, метод then</h3>

  <p>Объект Promise служит связующим звеном между исполнителем («создающим» кодом) и 
    функциями-потребителями, которые получат либо результат, либо ошибку. Функции-потребители 
    могут быть зарегистрированы (подписаны) с помощью методов .then, .catch и .finally.<br>
    Или можна сказать по-другому: Для того чтобы получить результат работы promise, нам 
    необходимо навесить обработчики. Сделать мы это можем при помощи вызова <b><em>методов .then, 
      .catch и .finally.</em></b>
  </p>

  <p>Наиболее важный и фундаментальный метод – <b>.then;</b> Синтаксис:</p>

  <p class="code-ex">
    <code>
      <b>promise.then(</b><br>
        function(result) { /* обработает успешное выполнение */ },<br>
        function(error) { /* обработает ошибку */ }<br>
      <b>);</b><br>
    </code>
  </p>

  <p>Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние 
    «выполнен успешно», и получает результат.<br>
    Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен 
    с ошибкой», и получает ошибку.
  </p>
  
  <p class="code-ex">
    <code>
      promise.then(<b>function (data)</b> {console.log(data)}<br>
      );<br>
    </code>
  </p>

  <p>В примере выше первым аргументов then получает функцию, которая будет вызвана в случае, если 
    promise завершился успешно.
  </p>

  <p class="code-ex">
    <code>
      promise.then(function (data) {console.log(data)}, <b>function (err)</b> {console.error(err);}<br>
      );<br>
    </code>
  </p>

  <p>А в этом примере показано что если во время выполнения promise произошла ошибка, то позовется функция, 
    которая передается вторым аргументом.
  </p>

  <p>В нашем случае мы можем записать обработчики более лаконично, поскольку console.error и console.log 
    уже являются функциями.
  </p>

  <p class="code-ex">
    <code>
      promise.then(<b>console.log, console.error</b>);
    </code>
  </p>
  
  <p>Следует отметить, что метод then мы можем вызывать, даже если promise находится 
    в одном из двух resolved state.
  </p>

  <h3>catch</h3>

  <p>Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента:<br>
    <b>.then(null, errorHandlingFunction)</b> или можно воспользоваться методом:<br>
    <b>.catch(errorHandlingFunction)</b>, который сделает тоже самое. Вот пример:
  </p>

  <p class="code-ex">
    <code>
      let promise = new Promise((resolve, reject) => {<br>
        setTimeout(() => reject(new Error("Ошибка!")), 1000);<br>
      });<br>
      <br>
      // .catch(f) это тоже самое, что promise.then(null, f)<br>
      <b>promise.catch(alert);</b> // выведет "Error: Ошибка!" спустя одну секунду<br>
    </code>
  </p>

  <h3>finally</h3>

  <p>По аналогии с блоком finally из обычного try {...} catch {...}, у промисов также есть метод 
    finally. Вызов .finally(f) <b>похож на .then(f, f)</b>, в том смысле, что f выполнится в любом случае, 
    когда промис завершится: успешно или с ошибкой.<br>
    finally хорошо подходит для очистки, например остановки индикатора загрузки, его ведь нужно остановить 
    вне зависимости от результата.
  </p>

  <p class="code-ex">
    <code>
      new Promise((resolve, reject) => {<br>
        /* сделать что-то, что займёт время, и после вызвать resolve/reject */<br>
      })<br>
        // выполнится, когда промис завершится, независимо от того, успешно или нет<br>
        <b>.finally</b>(() => остановить индикатор загрузки)<br>
        .then(result => показать результат, err => показать ошибку)<br>
    </code>
  </p>

  <p>Но это не совсем псевдоним then(f,f), как можно было подумать. Существует несколько важных отличий:<br>
    1. Обработчик, вызываемый из finally, не имеет аргументов. В finally мы не знаем, как был завершён промис. 
    И это нормально, потому что обычно наша задача – выполнить «общие» завершающие процедуры.<br>
    2. Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.<br>
    3. Последнее, но не менее значимое: вызов .finally(f) удобнее, чем .then(f, f) – не надо дублировать 
    функции f.
  </p>

  <p>Например, здесь результат проходит через finally к then:</p>

  <p class="code-ex">
    <code>
      new Promise((resolve, reject) => {<br>
        setTimeout(() => resolve("result"), 2000)<br>
      })<br>
        <b>.finally</b>(() => alert("Промис завершён"))<br>
        .then(result => alert(result)); // <-- .then обработает результат<br>
    </code>
  </p>

  <p>А здесь ошибка из промиса проходит через finally к catch:</p>

  <p class="code-ex">
    <code>
      new Promise((resolve, reject) => {<br>
        throw new Error("error");<br>
      })<br>
        <b>.finally</b>(() => alert("Промис завершён"))<br>
        .catch(err => alert(err));  // <-- .catch обработает объект ошибки<br>
    </code>
  </p>

  <p>Это очень удобно, потому что finally не предназначен для обработки результата промиса. 
    Так что он просто пропускает его через себя дальше.
  </p>

  <h3>Promises - недостатки</h3>
    
  <p>При работе с promise, нам приходится писать немного больше кода, поскольку появляются 
    функции-обработчики, которые разделяют работу асинхронного кода и работу с результатом. 
    Кроме того, производительность promise немного ниже, чем производительность callback.
  </p>
    
  <h3>Promises - достоинства</h3>

  <p>Однако наряду с этими недостатками мы получаем целый ряд преимуществ. Самое главное преимущество 
    заключается в том, что мы отловим неконтролируемые исключения.
  </p> 
  
  <p>Давайте рассмотрим вот такой пример. Если во время чтения файла произошла неконтролируемая ошибка, 
    мы это можем проиллюстрировать, вызвав ее самостоятельно при помощи метода throw,
  </p>

  <p class="code-ex">
    <code>
      var promise = new Promise(function (resolve, reject) {<br>
        fs.readFile('data.json', function (err, data) {<br>
          if (err) {<br>
            reject(err);<br>
          } else {<br>
            throw new Error('Mu-ha-ha!');}<br>
        });<br>
      });<br>
    </code>
  </p>

  <p> то эту ошибку мы поймаем в обработчике, который передается вторым параметром в метод then. И мы 
    увидим на консоли сообщение об ошибке.
</p>

<p class="code-ex">
  <code>
    promise.then(console.log, console.error);<br>
    <br>
    в консоле: [Error: Mu-ha-ha]<br>
  </code>
</p>
    
<p>Еще одно преимущество заключается в том, что мы можем навесить несколько обработчиков. Это 
  называется цепочка promise.
</p>

<h3>Подитожим</h3>

<p>Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), 
  затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).<br>
  Promise – предоставляют удобный способ организации асинхронного кода.
</p>

<p>На promise можно навешивать колбэки двух типов:<br>
  1. onFulfilled – срабатывают, когда promise в состоянии «выполнен успешно».<br>
  2. onRejected – срабатывают, когда promise в состоянии «выполнен с ошибкой».
</p>

<p>Способ использования, в общих чертах, такой:<br>
  1. Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.<br>
  2. Внешний код, получив promise, навешивает на него обработчики.<br>
  3. По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) 
  или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.
</p>

<p>Универсальный метод для навешивания обработчиков: <b>promise.then(onFulfilled, onRejected)</b><br>
  <br>
  1. onFulfilled – функция, которая будет вызвана с результатом при resolve.<br>
  2. onRejected – функция, которая будет вызвана с ошибкой при reject.<br>
  С его помощью можно назначить как оба обработчика сразу, так и только один:
</p>

<p class="code-ex">
  <code>
    // onFulfilled сработает при успешном выполнении<br>
    promise.then(onFulfilled)<br>
    // onRejected сработает при ошибке<br>
    promise.then(null, onRejected)<br>
  </code>
</p>

<p>Функции resolve/reject принимают ровно один аргумент – результат/ошибку.
  Именно он передаётся обработчикам в .then
</p>

<p>На завершённых промисах обработчики запускаются сразу.<br>
  Если промис в состоянии ожидания, обработчики в .then/catch/finally будут ждать его. Однако, если 
  промис уже завершён, то обработчики выполнятся сразу:<br>
</p>

<p class="code-ex">
  <code>
    // при создании промиса он сразу переводится в состояние "успешно завершён"<br>
    let promise = new Promise(resolve => resolve("готово!"));<br>
    promise.then(alert); // готово! (выведется сразу)<br>
  </code>
</p>


<p><b>Промисификация</b><br>
Промисификация – это когда берут асинхронный функционал и делают для него обёртку, возвращающую промис.<br>
После промисификации использование функционала зачастую становится гораздо удобнее.<br>
</p>

  

</body>

</html>