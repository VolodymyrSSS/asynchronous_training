<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>asynchronous_theory1</title>
    <style>
    body {
        background-color: tan;
        margin: 0;
        font-family: Verdana, sans-serif;
    }

    .title {
        color: red;
        text-align: center;
        font-weight:700;
    }

    .code-ex {
        width: 40%;
        font-family: sans-serif;
        background-color: #bebebe;
        font-size: large;
        text-indent: 0;
        padding-left: 15px;
        margin: 0 auto;
    }

    p {
      text-indent: 30px;
    }

    </style>
</head>
<body>

  <h2 class="title">Асинхронный код: стек вызовов и очередь событий</h2>

  <p> Все примеры, которые мы вам показывали ранее, были написаны в синхронном стиле, то есть если 
    у нас было описано несколько функций, и мы вызывали их одну за другой, то мы всегда знали, 
    какую строчку кода исполняет интерпретатор. Все было достаточно просто и понятно. 
  </p>

  <p class="code-ex">
    <code>
      function grist() { return 'Перемолоть кофейные зерна'; }<br>
        function addWater() { return 'Добавить немного воды'; }<br>
        function toStove() { return 'Поставить на плиту'; }<br>
        <br>
        <b>это синхронный код:</b><br>
        grist(); // Перемолоть кофейные зерна<br>
        addWater(); // Добавить немного воды<br>
        toStove(); // Поставить на плиту<br>
    </code>
  </p>

  <p>С асинхронным кодом все немного сложнее. Для того, чтобы понять, как работает асинхронный код,<br> 
    давайте рассмотрим две новые структуры: <b><em>стек вызовов</em></b> и <b><em>очередь событий</em></b>.
  </p>

  <p>В JavaScript объекты размещаются в куче. Куча — это просто имя для обозначения большой неструктурированной 
    области памяти.<br>
    Вызов любой функции создает контекст выполнения (Execution Context). При вызове вложенной функции 
    создается новый контекст, а старый сохраняется в специальной структуре данных - стеке вызовов (Call 
    Stack).
  </p>

  <p>Стек вызовов — это структура данных, которой оперирует интерпретатор. Как только мы начинаем 
    исполнять наш код, интерпретатор складывает в стек вызовов анонимную функцию. Как только выполнение 
    нашего кода заканчивается, анонимная функция выталкивается из стека. Если при выполнении нашего 
    кода встречается вызов другой функции, то интерпретатор складывает эту функцию в стек вызовов.
  </p>

  <p class="code-ex">
    <code>
      function prepareCoffee() { toStove(); }<br>
      function toCheerUp() { prepareCoffee(); }<br>
      toCheerUp();<br>
      <br>
      <b>стек вызовов</b><br>
      4) toStove<br>
      3) prepareCoffee<br>
      2) toCheerUp<br>
      1) anonymous<br>
    </code>
  </p>

  <p>В нашем случае при выполнении анонимной функции мы встретили вызов функции toCheerUp. Соответственно, 
    мы положили ее в стек вызовов и начали ее интерпретировать. В функции toCheerUp мы встречаем вызов 
    другой функции — prepareCoffee. Соответственно, мы складываем эту функцию в стек вызовов и идем ее 
    интерпретировать. В функции prepareCoffee мы вызываем функцию toStove, которая в свою очередь выводит 
    на консоль некоторую строку. Как только интерпретация этой функции заканчивается, функция пропадает из 
    стека, и мы возвращаемся к предыдущей функции, в нашем случае — к функции prepareCoffee. Вместе с 
    вызовом функции toStove заканчивается и вызов функции prepareCoffee. Значит, и она тоже достается из 
    стека. Аналогичным образом мы поступаем с двумя оставшимися функциями. Они пропадают из стека, и 
    выполнение нашего кода заканчивается.
  </p>

  <p>Вы уже неоднократно могли сталкиваться со стеком вызовов, когда допускали неконтролируемые исключения. 
    Давайте рассмотрим следующий пример. Перепишем функцию toStove таким образом, чтобы она выбрасывала 
    исключение при помощи метода throw. Таким образом, если мы дойдем по стеку вызовов до функции toStove, 
    и она выбросит исключение, то в консоли мы увидим следующую ошибку: мы не можем поставить кофе на плиту, 
    потому что нет электричества, и увидим стек вызовов, где ошибка произошла.
  </p>

  <p class="code-ex">
    <code>
      function toStove() { throw new Error('No electricity'); }<br>
      function prepareCoffee() { toStove(); }<br>
      function toCheerUp() { prepareCoffee(); }<br>
      toCheerUp();<br>
      <br> 
      in Console<br>
      Uncaught Error: No electricity<br>
      at toStove ('anonymous>:2:11)<br>
      at prepareCoffee ('anonymous>:6:5)<br>
      at toCheerUp ('anonymous>:10:5)<br>
      at 'anonymous>:13:1<br>
    </code>
  </p>

  <p>
    Еще одна структура данных, которая понадобится нам для понимания работы асинхронности в JavaScript — 
    это очередь событий. Среда выполнения JavaScript содержит очередь задач. Эта очередь — список задач, 
    подлежащих обработке. Каждая задача ассоциируется с некоторой функцией, которая будет вызвана, чтобы 
    обработать эту задачу.<br>
    Как только интерпретатор начинает исполнять наш код, он складывает анонимную функцию не сразу в стек 
    вызовов, а для начала помещает ее в очередь событий.<br>
    Далее работа очереди и стека согласуются следующим образом: как только стек вызовов пустеет, он достает 
    первую функцию из очереди событий. В нашем случае это анонимная функция. То есть она как бы перекладывается 
    из очереди событий в стек вызовов. Далее мы начинаем интерпретировать код, который написан в анонимной 
    функции. Встречаем вызов функции toCheerUp, она вызывает функцию prepareCoffee, она вызывает функцию 
    toStove и т.д. Мы складываем функции в стек вызовов, как только функции завершаются, мы достаем их из 
    стека вызовов. Как только стек опустел, наша программа снова обращается к очереди событий, и если там 
    есть новая функция, то она перекладывает ее в стек вызовов и начинает ее исполнять. В нашем случае в 
    очереди событий ничего нет, значит, наша программа завершится. Таким образом работает цикл событий. В 
    стек вызовов функция может попадать из очереди событий или если мы вызываем код внутри нашей функции. 
    А в очередь событий функция попадает не только когда мы начинаем выполнять наш код.  
  </p>

  <p class="code-ex">
    <code>
      function toStove() { ... }<br>
      function prepareCoffee() { toStove(); }<br>
      function toCheerUp() { prepareCoffee(); }<br>
      toCheerUp();<br>
      <br>
      <b>Очередь событий:</b><br>
      anonymous<br>
      move to stack: anonymous->toCheerUp->prepareCoffee->toStove
    </code>
  </p>

  <p>Можно обобщить, когда стек полностью освобождается, самая первая задача извлекается из очереди 
    и обрабатывается. Обработка задачи состоит в вызове  ассоциированной с ней функции с параметрами, 
    записанными в этой задаче. Как обычно, вызов функции создаёт новый контекст выполнения и заносится 
    в стек вызовов. Обработка задачи заканчивается, когда стек снова становится пустым. Следующая задача извлекается из 
    очереди и начинается её обработка.
  </p>

  <h3>Цикл событий</h3>

  <p>Модель событийного цикла (event loop) называется так потому, что отслеживает новые события в цикле:</p>

  <p class="code-ex">
    <code>
      while(queue.waitForMessage()){<br>
        queue.processNextMessage();<br>
      }<br>
    </code>
  </p>

  <p>queue.waitForMessage ожидает поступления задач, если очередь пуста.</p>

  <p>Каждая задача выполняется полностью, прежде чем начнет обрабатываться следующая. Благодаря 
    этому мы точно знаем: когда выполняется текущая функция – она не может быть приостановлена 
    и будет целиком завершена до начала выполнения другого кода (который может изменить данные, 
    с которыми работает текущая функция). Это отличает JavaScript от такого языка программирования 
    как C. Поскольку в С функция, запущенная в отдельном потоке, в любой момент может быть остановлена, 
    чтобы выполнить какой-то другой код в другом потоке.<br>
    У данного подхода есть и минусы. Если задача занимает слишком много времени, то веб-приложение 
    не может обрабатывать действия пользователя в это время (например, скролл или клик). Браузер 
    старается смягчить проблему и выводит сообщение "скрипт выполняется слишком долго" ("a script 
    is taking too long to run") и предлагает остановить его. Хорошей практикой является создание задач, 
    которые исполняются быстро, и если возможно, разбиение одной задачи на несколько мелких.
  </p>

  <p>В браузерах события добавляются в очередь в любое время, если событие произошло, а так же если у 
    него есть обработчик. В случае, если обработчика нет – событие потеряно. Так, клик по элементу, 
    имеющему обработчик события по событию click , добавит событие в очередь, а если обработчика нет – 
    то и событие в очередь не попадет.<br>
    Очень интересное свойство цикла событий в JavaScript, что в отличие от множества других языков, 
    поток выполнения никогда не блокируется. Обработка I/O обычно осуществляется с помощью событий и 
    функций обратного вызова, поэтому даже когда приложение ожидает запрос от IndexedDB или ответ от 
    XHR, оно может обрабатывать другие процессы, например пользовательский ввод.<br>
    Существуют хорошо известные исключения как alert или синхронный XHR, но считается хорошей практикой 
    избегать их использования.
  </p>

  <h3>Связь нескольких потоков между собой</h3>

  <p>Web Worker или кросс-доменный фрейм имеют свой собственный стек, кучу и очередь событий. Два 
    отдельных событийных потока могут связываться друг с другом, только через отправку сообщений с 
    помощью метода postMessage. Этот метод добавляет сообщение  в очередь другого, если он конечно 
    принимает их.<br>
  </p>


</body>

</html>