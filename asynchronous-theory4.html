<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>asynchronous_theory4</title>
    <style>
    body {
        background-color: tan;
        margin: 0;
        font-family: Verdana, sans-serif;
    }

    .title {
        color: red;
        text-align: center;
        font-weight:700;
    }

    .code-ex {
        width: 50%;
        font-family: sans-serif;
        background-color: #bebebe;
        font-size: large;
        text-indent: 0;
        padding-left: 15px;
        margin: 0 auto;
    }

    p {
      text-indent: 30px;
    }

    </style>
</head>
<body>

  <h2 class="title">Асинхронный код: функция обратного вызова (callback)</h2>

  <h3>Kак устроены callback-и в Node.js?</h3>

  <p>Callback или функция обратного вызова в Node.js выглядит следующим образом:</p>

  <p class="code-ex">
    <code>
      function cb(err, data) {<br>
        if (err) {<br>
          console.error(err.stack);<br>
        } else {<br>
          console.log(data); }<br>
      }<br>
    </code>
  </p>

  <p>Первым аргументом она принимает ошибку. Это ошибка, которая возникла в результате асинхронной 
    операции. Если при выполнении асинхронной операции не возникло ошибок, то в качестве первого 
    аргумента принято передавать null.<br>
    Второй аргумент содержит данные, с которыми завершилась асинхронная операция. В нашем случае — 
    чтение файла — в переменной data будет лежать содержимое этого файла.
  </p>

  <h3>callback - достоинства</h3>

  <p>Используя callback-и для работы с асинхронным кодом, мы можем написать оптимальный по 
    производительности код, поскольку мы не добавляем никаких накладных расходов. Кроме того, 
    нам не нужны никакие дополнительные модули или библиотеки для того, чтобы реализовать этот подход.
  </p>

  <h3>callback - недостатки</h3>

  <p>Однако вместе с достоинствами мы получаем целый ряд недостатков. Первый из них заключается в том, 
    что <em>уровень вложенности нашего кода растет вместе с ростом его сложности</em>.<br>
    Давайте рассмотрим следующий пример. В этом примере мы читаем файл data.json и обрабатываем результат, 
    то есть выводим на консоль в предпоследней строке. Эта строка находится на втором уровне вложенности, 
    что достаточно много.
  </p>
    
  <p class="code-ex">
    <code>
      var fs = require('fs');<br>
      <br>
      fs readFile('data.json', function (err, data) {<br>
        if (err) {<br>
          console.error(err.stack);<br>
        } else {<br>
          console.log(<b>data</b>); }<br>
      });<br>
    </code>
  </p>

  <p>Однако если мы захотим прочитать еще один файл, например, файл ext.json в случае, если 
    файл data.json был прочитан удачно, то обработчик положительного результата будет 
    находиться уже аж на четвертом уровне вложенности, и ситуация будет ухудшаться с 
    увеличением сложности нашего кода. 
  </p>

  <p class="code-ex">
    <code>
      var fs = require('fs');<br>
      <br>
      fs readFile('data.json', function (err, data) {<br>
        if (err) {<br>
          console.error(err.stack);<br>
        } else {<br>
          fs.readFile('ext.json', function (e, ext) {<br>
            if(e) {<br>
              console.error(e.stack);<br>
            } else {<br>
              console.log(<b>data</b> + ext);}<br>
          });<br>
        }<br>
      });<br>
    </code>
  </p>
    
  <p>Следующая проблема заключается в том, что <em>обработчик ошибок и данных, разных по своей природе, 
    находится в одном месте кода</em>.
  </p>

  <p>Вы, наверное, обратили внимание, что все наши callback-и начинались с if. Если в переменной 
    error находится какая-то ошибка, то мы идем по одной ветке кода, иначе — идем по другой ветке 
    кода. Конечно же, это увеличивает сложность нашего кода.
  </p>

  <p>Следующая проблема заключается в том, что мы <em>можем пропустить некоторые исключения, когда пишем 
    функцию, которая принимает callback</em>. Давайте рассмотрим это на примере.
  </p>

  <p>Мы хотим прочитать два файла параллельно. Для этого реализуем функцию readTwoFiles, которая 
    принимает один единственный аргумент, callback. Первой строчкой кода мы создадим переменную 
    tmp, которая в себе будет содержать результат чтения первого файла. Далее мы запускаем чтение 
    двух файлов: data.json и ext.json. Файл, который будет прочитан первым, окажется в переменной 
    tmp. Файл, который будет прочитан второй по счету, вызовет функцию callback. При этом в качестве 
    данных он передаст конкатинацию своего содержимого и переменной tmp.
  </p>

  <p class="code-ex">
    <code>
      var fs = require('fs');<br>
      <br>
      function readTwoFiles(cb) {<br>
        var tmp<br>
          fs.readFile(<b>'data.json'</b>, function (err, data) {<br>
            if (tmp) {cb(err, data + tmp); }<br>
            else { tmp = data; }<br>
          });
          <br>
          fs.readFile(<b>'ext.json'</b>, function (err, data) {<br>
            if(tmp) {cb(err, tmp + data); }<br>
            else {tmp = data; }<br>
          });<br>
        }<br>
    </code>
  </p>
    
  <p>Однако если мы при написании нашего кода допустим неконтролируемое исключение, например, мы можем 
    это симулировать при помощи вызова метода throw, то вызывающая сторона, то есть код, который позовет 
    нашу функцию readTwoFiles, никогда не получит callback с ошибкой. Мы пропустили эту ошибку и сделали 
    наш код ненадежным.
  </p>

  <p class="code-ex">
    <code>
      var fs = require('fs');<br>
      <br>
      function readTwoFiles(cb) {<br>
        var tmp<br>
          fs.readFile('data.json', function (err, data) {<br>
            if (tmp) {cb(err, data + tmp); }<br>
            else { <b>throw Error('Mu-ha-ha!');</b> }<br>
          });
          <br>
          fs.readFile('ext.json', function (err, data) {<br>
            if(tmp) {cb(err, tmp + data); }<br>
            else {tmp = data; }<br>
          });<br>
        }<br>
    </code>
  </p>

  <p>Вы, наверное, уже обратили внимание на переменную tmp. Она выглядит очень неуместно, и так 
    получается, когда мы пишем сложный код с использованием callback-ов. Для синхронизации мы 
    используем <em>такие переменные, и они тоже увеличивают сложность нашего кода</em>.
  </p> 

  <h3>callback - когда использовать</h3>
    
  <p>Однако использование callback-ов для работы с асинхронным кодом — широко используемый подход, 
    и я рекомендую вам его применять в двух случаях: если вам нужно написать высокопроизводительный код, 
    который будет работать максимально быстро, или если вы пишете код какой-то внешней библиотеки, 
    которая будет использоваться другими программистами. Callback-и являются стандартом де-факто работы 
    с асинхронным кодом. Кроме того, вы не должны лишать возможности других программистов написать свой 
    код максимально производительным.
  </p>

</body>

</html>