<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>asynchronous_theory6</title>
    <style>
    body {
        background-color: tan;
        margin: 0;
        font-family: Verdana, sans-serif;
    }

    .title {
        color: red;
        text-align: center;
        font-weight:700;
    }

    .code-ex {
        width: 50%;
        font-family: sans-serif;
        background-color: #bebebe;
        font-size: large;
        text-indent: 0;
        padding-left: 15px;
        margin: 0 auto;
    }

    p {
      text-indent: 30px;
    }

    </style>
</head>
<body>

  <h2 class="title">Асинхронный код: чейнинг или цепочки промисов</h2>

  <h3>Работа цепочка промисов</h3>

  <p>«Чейнинг» (chaining), или объединение промисов в цепочке, позволяет написать сложный асинхронный код 
    гораздо проще. На предыдущем занятии мы рассмотрели с вами использование промисов для чтения 
    файлов. В случае, если файл был прочитан успешно, мы выводили на консоль содержимое этого файла. 
    Если же чтение завершалось с ошибкой, на консоли оказывалось сообщение об ошибке. В этом занятии 
    мы рассмотрим, как зачейнить промисы, объединить их в цепочки и написать более сложный код.
  </p>

  <p>Чейнинг, то есть возможность строить асинхронные цепочки из промисов – пожалуй, 
    основная причина, из-за которой существуют и активно используются промисы.
  </p>

  <p>
    Например, мы хотим по очереди:<br>
    Загрузить данные посетителя с сервера (асинхронно).<br>
    Затем отправить запрос о нём на github (асинхронно).<br>
    Когда это будет готово, вывести его github-аватар на экран (асинхронно).<br>
    …И сделать код расширяемым, чтобы цепочку можно было легко продолжить.<br>
  </p>
    
  <p>Чтобы лучше понять, как работает цепочка промисов, давайте рассмотрим две следующие функции.<br>
    Первая функция — identity возвращает результат, который мы передаем ей, как есть, без изменений.<br>
    Вторая функция — thrower. Она выбрасывает исключения с теми данными, которые мы передаем ей первым 
    аргументом.
  </p>

  <p class="code-ex">
    <code>
      function identity(data) {<br>
        return data;<br>
        } <br>
        <br>
      function thrower(err) {<br> 
      throw err;<br>
      }<br>
      <br>
    </code>
  </p>
      
  <p>Мы можем переписать наш пример следующим образом.</p> 

  <p class="code-ex">
    <code>
      promise<br>
      .then(console.log, thrower)<br>
      .then(identity, console.error);<br>
    </code>
  </p>
      
  <p>Вызываем метод then у нашего промиса, который читает файл, и первым аргументом передаем 
    console.log. То есть выводим содержимое файла на консоль. В качестве второго аргумента мы 
    указываем функцию thrower. То есть если при чтении файла произошла ошибка, функция thrower 
    пробросит ее дальше по цепочке промисов.
  </p>

  <p>После того как мы вызвали метод then первый раз, создается новый промис, у которого мы 
    также можем позвать метод then. В качестве первого аргумента мы указываем метод identity. 
    В качестве второго аргумента мы указываем console.error, то есть выводим произошедшую ошибку 
    на консоль.<br>
    Из полученной цепочки промисов становится понятно, что на консоли ошибка окажется не только в 
    случае, если чтение файла закончилось неудачно, но и в случае, если обработчик данных содержит 
    неконтролируемые исключения.
  </p>

  <p>Давайте рассмотрим более сложный пример, чтобы понять, в чем заключается сила цепочки промисов. 
    Так же как и в предыдущем случае, в промисе мы будем асинхронно читать некоторые файлы.
  </p>

  <p class="code-ex">
    <code>
      promise<br>
      .then(JSON.parse, thrower)<br>
      .then(identity, getDefault)<br>
      .then(getAvatar, thrower)<br>
      .then(identity, console.error);<br>
    </code>
  </p>
    
  <p>Если чтение файла завершилось хорошо, мы вызовем функцию JSON.parse, Эта функция преобразует 
    содержимое файла в JSON. Если чтение завершилось с ошибкой, мы вызываем функцию thrower. Эта 
    функция опрокидывает ошибку далее по цепочке промисов. Если парсинг завершился хорошо, то мы 
    попадаем в метод identity, то есть прокидываем полученные данные дальше по цепочке промисов как 
    есть. А если при чтении файла или при парсинге данных произошла ошибка, мы вызываем метод getDefault.
  </p>

  <p class="code-ex">
    <code>
      function getDefault() {<br>
        return { name: 'Sergey' };<br>
        }<br>
    </code>
  </p>
    
  <p>Это метод возвращает некоторый JSON, который позволит нам дальше работать с данными.<br>
    <em>Здесь я немного остановлюсь и отмечу один факт. Если в цепочке промисов встречается обработчик, 
      который ответственен за ошибку, и мы в него попадаем, то цепочка промисов переходит из состояния 
      rejected в состояние fulfilled.</em>
  </p> 
      
  <p>То есть далее мы попадем в метод getAvatar.</p>

  <p class="code-ex">
    <code>
      function getAvatar (data) {<br>
        var name = data.name;<br>
        return request('https://my.avatar/' + name);<br>
      }<br>
    </code>
  </p>
  
  <p>Этот getAvatar делает асинхронный запрос на удаленный сервер за аватаром пользователя. В качестве 
    второго колбека, то есть в качестве второго обработчика ошибки, мы передаем метод thrower.
  </p>
  <p>Замыкает цепочку промисов следующая пара. Первым аргументом мы передаем метод identity — он возвращает 
    результат, который получили с удаленного сервера, то есть аватар пользователя как есть. А в качестве 
    второго колбека мы указываем функцию console error. Эта функция выводит на консоль ошибку, которая 
    получилась при запросе на удаленный сервер.
  </p>
  
  <p>Из этой цепочки промисов становится понятно, что если какая-то асинхронная операция завершилась с 
    ошибкой, то мы, обработав эту ошибку, можем создать новый промис, который уже находится в состоянии fulfilled.
  </p>
    
  <p>Давайте еще раз повторим правила, по которым осуществляются переходы по цепочке промисов.<br>
    1. Если очередной обработчик, который мы навесили в методе then, возвращает данные, то мы передаем 
    эти данные дальше по цепочке промисов как есть.<br>
    2. Если в then возвращается промис, то мы дожидаемся, пока выполнится этот промис, и далее передаем 
    уже результат его работы.<br>
    3. Если в обработчике происходят неконтролируемые исключения, то промис переходит в состояние rejected.
  </p>
  
  <p>Полученный код мы можем записать еще короче. Мы можем убрать все функции thrower и identity по 
    следующим правилам.
  </p>

  <p class="code-ex">
    <code>
      promise<br>
      .then(JSON.parse, <b>thrower</b>)<br>
      .then(<b>identity</b>, getDefault)<br>
      .then(getAvatar, <b>thrower</b>)<br>
      .then(<b>identity</b>, console.error);<br>
    </code>
  </p>
  
  <p>Функции thrower мы просто убираем, а все методы then, которые принимают первым 
    аргументом функцию identity, мы заменяем на метод catch. Таким образом, наш код выглядит вот так.
  </p>

  <p class="code-ex">
    <code>
      promise<br>
      .then (JSON.parse)<br>
      <b>.catch</b> (getDefault)<br>
      .then(getAvatar)<br>
      <b>.catch</b> (console.error);<br>
    </code>
  </p>

  <p>Следует заметить, что код:</p>

  <p class="code-ex">
    <code>
      promise<br>
        .then(JSON.parse)<br>
        .then(getAvatar);<br>
    </code>
  </p>

  <p>не то же самое что:</p>

  <p class="code-ex">
    <code>
      promise.then(JSON.parse);<br>
      promise.then(getAvatar);<br>
    </code>
  </p>

  <h3>Параллельное выполнение промисов</h3>
  
  <p>Еще одна тема, которую мы сегодня рассмотрим, это параллельное выполнение промисов. Так же, как и 
    в случае с колбеками, мы будем параллельно читать два файла. Для этого давайте реализуем функцию 
    readFile, которая на вход принимает путь до файла и возвращает новый промис, который читает файл.
  </p>

  <p class="code-ex">
    <code>
      function readFile(name) {<br>
        return new Promise(function (resolve, reject) {<br>
          fs.readFile(name, function (err, data) {<br>
            err ? reject(err) : resolve(data);});<br>
        });<br>
      }<br>
    </code>
  </p>

  <p>Для того чтобы запустить чтение двух файлов параллельно, нам нужно вызвать метод Promise all с 
    массивом промисов.
  </p>

  <p class="code-ex">
    <code>
      Promise<br>
        .all([<br>
          readFile('data.json'),<br>
          readFile('ext.json')<br>
        ])<br>
        .then(function (data) {<br>
          console.log(data[0] + data[1])<br>
        });<br>
    </code>
  </p>
  
  <p>Если оба файла прочитаются успешно, то мы вызываем обработчик, который навесили 
    при помощи метода then. В этом обработчике мы получим массив из двух элементов. 
    Первый элемент содержит первый файл, во втором элементе будет лежать содержимое 
    второго файла.
  </p>
  
  <p> Для того чтобы создать промисы без совершения асинхронных операций, мы можем позвать метод Promise 
    resolve. Этот метод создаст нам новый промис, который переходит в состояние fulfiled с теми данными, 
    которые мы передали в качестве аргумента в метод resolve. 
  </p>

  <p class="code-ex">
    <code>
      Promise<br>
        .resolve('{"name": "Sergey"}')<br>
        .then(console.log);<br>
        <br>
        in console we get: {"name": "Sergey"}<br>
    </code>
  </p>

  <p>Парный к нему метод reject создает промис, 
    который находится в состоянии rejected с той ошибкой, которую мы передали в метод reject.
  </p>

  <p class="code-ex">
    <code>
      Promise<br>
        .reject(new Error(Mu-ha-ha!') )<br>
        .catch(console.error);<br>
        <br>
        in console we get: [Error: Mu-ha-ha!]<br>
    </code>
  </p>

</body>

</html>